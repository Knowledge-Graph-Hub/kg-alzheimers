# Title
DADA2: High resolution sample inference from Illumina amplicon data

# Abstract
We present DADA2, a software package that models and corrects Illumina-sequenced amplicon errors. DADA2 infers sample sequences exactly, without coarse-graining into OTUs, and resolves differences of as little as one nucleotide. In several mock communities DADA2 identified more real variants and output fewer spurious sequences than other methods. We applied DADA2 to vaginal samples from a cohort of pregnant women, revealing a diversity of previously undetected Lactobacillus crispatus variants.

## Online Methods
The core denoising algorithm in the DADA2 R package is built on a model of the errors in Illumina-sequenced amplicon reads. This error model quantifies the rate λ ji at which an amplicon read with sequence i is produced from sample sequence j as a function of sequence composition and quality. A Poisson model for the number of repeated observations of the sequence i , parameterized by the rate λ ji , is then used to calculate the p-value of the null hypothesis that the number of amplicon reads (the abundance) of sequence i is consistent with the error model. These p-values are used as the division criteria for an iterative partitioning algorithm, which continues dividing sequencing reads until all partitions are consistent with being produced from their central sequence 5 . We now describe each of these steps in detail.

Pairwise sequence alignments are performed by a vectorized implementation of the Needleman-Wunsch algorithm with ends-free gapping. As alignment dominates the computational costs of the algorithm, two heuristics are enabled by default. The first heuristic is the use of a kmer-distance screen prior to alignment. If the kmer-distance between i and j exceeds a user-settable parameter ( KDIST_CUTOFF ), no alignment is performed 21 . The default value of this parameter was chosen to exclude only pairs of reads with >10% nucleotide mismatch. The second heuristic is banded alignment, which forgoes calculation of potential alignments in which the net number of gaps of one sequence relative to the other exceeds a user-settable parameter ( BAND_SIZE ). The default value of this parameter was chosen to minimally impact the alignment of sequences with few indels, such as ribosomal RNA genes. Both heuristics can be disabled by the user, and the default values should be re-examined if the algorithm is applied to genetic regions with significantly different characteristics, such as the indel-rich ITS region.

DADA2 models errors as occurring independently within a read, and independently between reads. Under this model, the rate at which an amplicon read with sequence i is produced from sample sequence j is reduced to the product over the transition probabilities between the L aligned nucleotides: λ j i = ∏ l = 0 L p ( j ( l ) → i ( l ) , q i ( l ) ) The transition probability between aligned nucleotides is allowed to depend on the original nucleotide, substituting nucleotide, and associated quality score, e.g. p(A→C, 35).

After sequence alignment, the error rate λ ji is calculated and stored. If sequences i and j were not aligned because they exceeded the kmer-distance cutoff λ ji is set to 0.

The abundance p-value quantifies the notion that sequence i is too abundant for it to be explained by errors in amplicon sequencing. If sequencing errors are independent across reads, the number of amplicon reads with sequence i that will be produced from sample sequence j is Poisson distributed with expectation equal to an error rate λ ji multiplied by the expected reads of sample sequence j . Let unique sequence i with abundance a i be in partition j containing n j reads. Then, conditional on i being read at least once, the abundance p-value is the probability of seeing that many or more identical reads ( ρ pois is the Poisson density function): p A ( j → i ) = 1 1 − ρ pois ( n j λ j i , 0 ) ∑ a = a i ∞ ρ pois ( n j λ j i , a ) A low p A indicates that there are more reads of sequence i than can be explained by errors introduced during the amplification and sequencing of n j copies of sample sequence j .

Note that the abundance p-value is calculated conditional on at least one sequence being observed. As a result, all singleton sequences have an abundance p-value of 1, and are never judged inconsistent with the error model. This means that singletons cannot form their own partitions, and DADA2 will not infer singleton sequences. The effect of this is similar in practice to the UPARSE developer's recommendation to remove singleton sequences prior to picking OTUs, and in both cases is driven by the difficulty in robustly differentiating singleton errors from real singleton sequences.

First, amplicon reads with the same sequence are grouped into unique sequences with an associated abundance and consensus quality profile (or dereplicated). The divisive partition algorithm is initialized by placing all unique sequences into a single partition, and assigning the most abundant sequence as the center of that partition. All unique sequences are then compared to the center of their partition, error rates are calculated and stored, and the abundance p-value is calculated for each unique sequence. If the smallest p-value, after bonferroni correction, falls below the user-settable threshold OMEGA_A , a new partition is formed with the unique sequence with the smallest p-value as its center, and all unique sequences are compared to the center of that new partition.

After a new partition is formed, every unique sequence is allowed to join the partition most likely to have produced it (i.e. that produces the highest expected number of that unique sequence). At that point the division procedure iterates, with each iteration consisting of identifying the unique sequence with the smallest p-value, forming a new partition with that sequence as its center, and reshuffling sequences to their most likely partition.

Division continues until all abundance p-values are greater than OMEGA_A , i.e. all unique sequences are consistent with being produced by amplicon sequencing the center of their partition. The inferred composition of the sample is then the set of central sequences and the corresponding total abundances of those partitions (alternatively: each read is denoised by replacing it with the central sequence of its partition).

A detailed description of the original version of this divisive algorithm is available in Rosen et al. 2012 5 . The DADA2 implementation has been slightly simplified for computational speed, in particular there is no longer any construction of “indel families”.

DADA2 depends on a parameterized error model (the 16 × 41 transition probabilities, e.g. p(A→C, 35) but if those parameters are not known a priori then DADA2 can estimate them from the data.

Given an inferred partition of the amplicon sequences, DADA2 records the mismatches between every sequence and the center of its partition, and counts each type of mismatch (e.g. the number of A→C mismatches where Q=35). That table of observed mismatches represents the errors inferred by DADA2, and can be used to estimate the parameters of the error model. DADA2's default parameter estimation method is to perform a weighted loess fit to the regularized log of the observed mismatch rates as a function of their quality, separately for each transition type (e.g. A→C mismatches are fit separately from A→G mismatches). However, the error rate estimation function is a modular part of the algorithm, and the user is able to provide their own R function to estimate the parameters of the error model from the observed mismatches if they prefer a different method.

DADA2's selfConsist mode alternates sample inference (conditional on the parameters of the error model) with parameter estimation (conditional on the inferred sample composition) until convergence, at which point jointly consistent estimates of the error parameters and sample composition are reported. This improves the accuracy of DADA2: while Illumina quality scores are informative, they do not exactly match their textbook definition ( Supplementary Fig. 8 ), and we have observed significant variation in this relationship between different runs. The plotErrors function in the DADA2 R package produced Supplementary Fig. 8 , and is a useful tool to visualize the observed and estimated error rates in various datasets.

The DADA2 R package implements a complete pipeline to turn paired-end fastq files from the sequencer into merged, denoised, chimera-free, inferred sample sequences. Parts of this pipeline can be substituted with outside methods, but there are some structural differences between the DADA2 pipeline and most others. One such difference is that the DADA2 pipeline performs merging of paired-end reads after denoising. This is because the core denoising algorithm uses the empirical relationship between the quality score and the error rates. When reads are merged, this relationship will differ between the forward-only, overlapping, and reverse-only portions of the merged read. That variation interferes with the denoising algorithm, and therefore greater accuracy can be achieved by denoising before merging, albeit at some computational cost.

fastqFilter() implements filtering of fastq files that largely recapitulates the usearch fastq_filter command ( http://www.drive5.com/usearch/manual/cmd_fastq_filter.html ). In short, this function trims sequences to a specified length, removes sequences shorter than that length, and filters based on the number of ambiguous bases, a minimum quality score, and the expected errors in a read 18 . fastqPairedFilter() implements the same trimming and filtering, but applies it to paired reads jointly, only outputting reads where both the forward and reverse reads pass the filter.

derepFastq() imports a fastq file and outputs a dereplicated list of unique sequences and their abundances. derepFastq() also outputs consensus positional quality scores for each unique sequence by taking the average (mean) of the positional qualities of the component reads. These consensus scores are used by the error model of the dada() function.

dada() implements the core denoising algorithm described above.

isBimeraDenovo() identifies sequences that are exact bimeras (two-parent chimeras) of more abundant output sequences. Bimeras are identified by performing a Needleman-Wunsch global alignment of each sequence to all more abundant sequences, and then searching for combinations of a left-parent and a right-parent that cover the child sequence without any mismatches or internal indels. Child sequences that differ by a single mismatch or indel from the chimeric model are also flagged if the left-parent and right-parent are both at least 4-away from the child sequence.

isBimeraDenovo() is intended to be used after denoising, and on exactly inferred sample sequences, rather than on noisy input reads or fuzzy OTUs. It was necessary to implement isBimeraDenovo() because most current stand-alone chimera identification programs are intentionally conservative about identifying chimeras that are relatively close to other more abundant sequences, because such sequences are expected to be later joined together in the same OTU ( Supplementary Note 2 ). DADA2 does not create OTUs, and does differentiate closely related sequence variants, therefore we implemented this simple, but more sensitive, chimera detection method.

mergePairs() performs a global ends-free alignment between paired forward and reverse reads, and merges them together if they exactly overlap. mergePairs() requires that the input forward and reverse reads read in by derepFastq() were in the same order, a feature which is maintained by fastqPairedFilter() . Note that merging in the DADA2 pipeline happens after denoising, hence the strict requirement of exact overlap since it is expected that nearly all substitution errors have already been removed.

The Balanced community consists of 57 bacteria and archaea from a broad range of habitats. The 16S rRNA gene sequences of most of these strains were well separated (>3%) over the region sequenced. However, the sequences of 5 strains were identical to other more abundant strains, while 5 strains had a total of 7 additional distinguishable sequence variants in their genomes that differed by 1 or 2 nucleotides. There were also two strains that were less than 3% different from more abundant strains. The Balanced dataset was downloaded from http://www.ebi.ac.uk/ena/data/view/PRJEB6244 , and its construction was described in [ 16 ] where it is identified as dataset DS 35.

The HMP community consists almost entirely of strains well separated (>3%) over the region sequenced ( S. epidermis and S. aureus are indistinguishable), most of which colonize the human body. The HMP dataset was downloaded from http://www.mothur.org/MiSeqDevelopmentData.html , and its construction was described in [ 17 ] where it is identified as the MOCK1 sample in run 130403. This dataset was also analyzed in [ 18 ].

The Extreme dataset was generated for this study. The organisms for the Extreme community include human gastrointestinal tract bacterial isolates ( Supplementary Table 2 ). The Extreme dataset was intended to include more fine-scale variation than the other mock communities, the members of which were chosen in part for their well-separated 16S rRNA gene sequences. The Extreme strains are all distinguishable over the sequenced region of the 16S rRNA gene, but some pairs of strains differ by as little as 1 nucleotide. The Extreme dataset is available under SRA accession number SRX1478507.

Extreme strains were grown overnight in liquid broth with the medium recommended from the source culture collection for each respective strain ( Table 1 ). An aliquot of the bacterial culture was used to directly amplify the 16S rRNA gene. One microliter of the bacterial culture was used as template to amplify the V4 region of the 16S rRNA gene using fusion gene primers (515f/806r) that incorporate Illumina adapter sequences and indexing barcodes 22 . The PCR reaction was carried out in a 25 uL mixture containing 1× HotMaster Mix with 2.5 mM Mg2+ (5 PRIME, Gaithersburg, MD), 400 nM forward primer, 400 nM reverse primer, along with the bacterial culture template. The following cycling parameters were used: initial cell lysis and DNA denaturing at 95$^\circ$C for 10 minutes, followed by 30 cycles of 95°C for 30 seconds, 50°C for 30 seconds, and 72°C for 30 seconds, ending with a final annealing step at 72°C for 10 min. PCR amplicons were cleaned using Agencourt AMPure XP beads (Beckman Coulter, Pasadena, CA) following the manufacturer's instructions. Cleaned PCR amplicons were analyzed and quantified using an Agilent 2100 Bioanalyzer.

Strains were grouped into two taxonomic groups, Firmicutes and Bacteroidetes. Within each taxonomic group, strains were designated for one of six 10-fold dilution groups ( Supplementary Table 2 ). PCR amplicons for each strain were first normalized to the same concentration. From there, each amplicon was individually diluted to its respective dilution level and then all amplicons were pooled. The concentration of the pooled library was quantified using the Quant-iT PicoGreen dsDNA Assay kit (Life Technologies, Carlsbad, CA) and analyzed on an Agilent 2100 Bioanalyzer. The pooled library was diluted to 4 nM and then Illumina's protocol for preparing libraries for sequencing on the MiSeq was followed. The final concentration of the library was diluted to 6 pM with ~20% PhiX spiked in to account for the low base-diversity library. The final pooled library was sequenced on an Illumina MiSeq with a MiSeq Sequencing Reagent Kit v3 to obtain 250 bp paired end reads utilizing custom sequencing primers as described in [ 22 ].

A common filtering and trimming was performed before applying each method: The DADA2 fastqPairedFilter (paired reads) and fastqFilter (forward reads only) functions were used to remove sequences with Ns or more than two expected errors 18 , and to trim the first 20 nucleotides and the last 10 nucleotides (forward reads) or 10–50 nucleotides (reverse reads) depending on the quality profile of the data.

The usearch command fastq_mergepairs with a minimum overlap of 20 bases and maximum differences of 1 was used to merge the filtered forward and reverse reads for further analysis by UPARSE, MED and QIIME. Mothur used its native read merging function make.contigs . DADA2 denoised the forward and reverse reads independently, and then merged them with its mergePairs function.

Chimeras were removed from the denoised output of DADA2 and MED by isBimeraDenovo in the DADA2 R package, as this tool is intended for the exactly inferred sequences output by these methods. UPARSE has built-in chimera removal. The uchime method included in mothur and QIIME was used to remove chimeras for those pipelines 23 .

A list of output sequences and associated abundances was obtained for each algorithm. For DADA2 these were the inferred sample sequences, for UPARSE, mothur and QIIME the representative OTU sequences, and for MED the representative sequences of its “nodes”.

We also removed singleton OTUs from the outputs of mothur and QIIME. The DADA2, UPARSE and MED pipelines all decline to call singleton variants, so removing singletons from mothur and QIIME allows a cleaner comparison between methods. Additionally, nearly all of the singleton variants output by mothur and QIIME were spurious, so removing singletons improved their reported accuracy.

Software versions: DADA2 version 0.99.8, usearch version 8.1.1831 (implements UPARSE), MED version 2.0, mothur version 1.36.1, QIIME version 1.9.1.

Output sequences were first compared to the known 16S rRNA gene reference sequences of the members of each mock community. If an output sequence matched a reference sequences, it was classified as Reference, and if it had one mismatch or gap to a reference sequence it was classified as One Off. Output sequences that were at least Hamming distance 2 from any reference sequence were then BLASTed against the nr/nt database. If the best hit was an exact match covering the full output sequence, it was classified Exact. If there was a single mismatch or indel, it was classified One Off. Output sequences that remained unclassified to this point were classified Other.

We included the BLAST against nr/nt step because even amplicon sequencing data from communities with a putatively known reference composition will contain contaminant sequences. Contaminants are real, albeit unwanted, biological variation, and should be identified when correcting amplicon errors. While the nr/nt database is imperfect, it is reasonable to expect that Exact matches are far more likely to be real variants than are Others. Output sequences classified as Other, and output sequences classified as One Off that differed by one substitution from a more abundant output sequence, were considered a proxy for false positives. Output sequences classified as Reference or Exact were considered true positives.

We compiled the 16S rRNA gene sequences (reference sequences) for the intended members of each mock community (reference strains). The presence of each reference strain was confirmed by checking that at least one read matching one of its 16S rRNA gene sequences was present in the filtered dataset. If no such read existed, that strain was removed from the reference list.

Output sequences were compared to the list of reference sequences. If any output sequence matched any 16S rRNA gene sequence present in a strain, that reference strain was considered to have been identified.

When benchmarking computational time, we attempted to isolate the core sample inference algorithms for each pipeline as much as possible. Thus, for the time benchmarking we applied each algorithm to an identically prepared set of sequences: the filtered forward-only reads from the Balanced dataset including singletons. We did not include chimera identification in this benchmarking. The specific commands benchmarked are listed at the end of the Balanced workflow.

Note that preprocessing steps, such as discarding singletons and reference-based chimera removal, can substantially reduce subsequent computation time for all of these methods.

The 16S rRNA gene amplicon data from human vaginal samples in [ 19 ] (2.13M paired-end Illumina Miseq reads in 157 samples) and from mouse feces in [ 17 ] (3.65M paired-end Illumina Miseq reads in 362 samples) were analyzed with the DADA2 pipeline outlined above. First the demultiplexed fastq files were filtered and trimmed in the same manner as the test datasets. Each sample was dereplicated, a portion of the dataset was used to estimate the error parameters, and dada() was applied to the full pooled dataset using those inferred error parameters. isBimeraDenovo() was used to remove chimeras.

For the human vaginal samples, output sequences that appeared in at least two samples and at least 0.3% of the total reads were taxonomically identified by BLAST. Further analysis focused on the six L. crispatus sequence variants identified by this procedure.